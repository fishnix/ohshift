// Code generated by BobGen psql v0.38.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"database/sql"
	"testing"
	"time"

	models "github.com/fishnix/ohshift/models"
	"github.com/gofrs/uuid/v5"
	"github.com/jaswdr/faker/v2"
	"github.com/stephenafamo/bob"
)

type IncidentMod interface {
	Apply(context.Context, *IncidentTemplate)
}

type IncidentModFunc func(context.Context, *IncidentTemplate)

func (f IncidentModFunc) Apply(ctx context.Context, n *IncidentTemplate) {
	f(ctx, n)
}

type IncidentModSlice []IncidentMod

func (mods IncidentModSlice) Apply(ctx context.Context, n *IncidentTemplate) {
	for _, f := range mods {
		f.Apply(ctx, n)
	}
}

// IncidentTemplate is an object representing the database table.
// all columns are optional and should be set by mods
type IncidentTemplate struct {
	ID             func() uuid.UUID
	SlackChannelID func() string
	Status         func() string
	Severity       func() string
	Title          func() string
	Description    func() sql.Null[string]
	StartedBy      func() string
	StartedAt      func() sql.Null[time.Time]
	ResolvedBy     func() sql.Null[string]
	ResolvedAt     func() sql.Null[time.Time]
	ExportURL      func() sql.Null[string]
	LastUpdated    func() sql.Null[time.Time]

	r incidentR
	f *Factory
}

type incidentR struct {
	TimelineEvents []*incidentRTimelineEventsR
}

type incidentRTimelineEventsR struct {
	number int
	o      *TimelineEventTemplate
}

// Apply mods to the IncidentTemplate
func (o *IncidentTemplate) Apply(ctx context.Context, mods ...IncidentMod) {
	for _, mod := range mods {
		mod.Apply(ctx, o)
	}
}

// setModelRels creates and sets the relationships on *models.Incident
// according to the relationships in the template. Nothing is inserted into the db
func (t IncidentTemplate) setModelRels(o *models.Incident) {
	if t.r.TimelineEvents != nil {
		rel := models.TimelineEventSlice{}
		for _, r := range t.r.TimelineEvents {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.IncidentID = o.ID // h2
				rel.R.Incident = o
			}
			rel = append(rel, related...)
		}
		o.R.TimelineEvents = rel
	}
}

// BuildSetter returns an *models.IncidentSetter
// this does nothing with the relationship templates
func (o IncidentTemplate) BuildSetter() *models.IncidentSetter {
	m := &models.IncidentSetter{}

	if o.ID != nil {
		val := o.ID()
		m.ID = &val
	}
	if o.SlackChannelID != nil {
		val := o.SlackChannelID()
		m.SlackChannelID = &val
	}
	if o.Status != nil {
		val := o.Status()
		m.Status = &val
	}
	if o.Severity != nil {
		val := o.Severity()
		m.Severity = &val
	}
	if o.Title != nil {
		val := o.Title()
		m.Title = &val
	}
	if o.Description != nil {
		val := o.Description()
		m.Description = &val
	}
	if o.StartedBy != nil {
		val := o.StartedBy()
		m.StartedBy = &val
	}
	if o.StartedAt != nil {
		val := o.StartedAt()
		m.StartedAt = &val
	}
	if o.ResolvedBy != nil {
		val := o.ResolvedBy()
		m.ResolvedBy = &val
	}
	if o.ResolvedAt != nil {
		val := o.ResolvedAt()
		m.ResolvedAt = &val
	}
	if o.ExportURL != nil {
		val := o.ExportURL()
		m.ExportURL = &val
	}
	if o.LastUpdated != nil {
		val := o.LastUpdated()
		m.LastUpdated = &val
	}

	return m
}

// BuildManySetter returns an []*models.IncidentSetter
// this does nothing with the relationship templates
func (o IncidentTemplate) BuildManySetter(number int) []*models.IncidentSetter {
	m := make([]*models.IncidentSetter, number)

	for i := range m {
		m[i] = o.BuildSetter()
	}

	return m
}

// Build returns an *models.Incident
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use IncidentTemplate.Create
func (o IncidentTemplate) Build() *models.Incident {
	m := &models.Incident{}

	if o.ID != nil {
		m.ID = o.ID()
	}
	if o.SlackChannelID != nil {
		m.SlackChannelID = o.SlackChannelID()
	}
	if o.Status != nil {
		m.Status = o.Status()
	}
	if o.Severity != nil {
		m.Severity = o.Severity()
	}
	if o.Title != nil {
		m.Title = o.Title()
	}
	if o.Description != nil {
		m.Description = o.Description()
	}
	if o.StartedBy != nil {
		m.StartedBy = o.StartedBy()
	}
	if o.StartedAt != nil {
		m.StartedAt = o.StartedAt()
	}
	if o.ResolvedBy != nil {
		m.ResolvedBy = o.ResolvedBy()
	}
	if o.ResolvedAt != nil {
		m.ResolvedAt = o.ResolvedAt()
	}
	if o.ExportURL != nil {
		m.ExportURL = o.ExportURL()
	}
	if o.LastUpdated != nil {
		m.LastUpdated = o.LastUpdated()
	}

	o.setModelRels(m)

	return m
}

// BuildMany returns an models.IncidentSlice
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use IncidentTemplate.CreateMany
func (o IncidentTemplate) BuildMany(number int) models.IncidentSlice {
	m := make(models.IncidentSlice, number)

	for i := range m {
		m[i] = o.Build()
	}

	return m
}

func ensureCreatableIncident(m *models.IncidentSetter) {
	if m.SlackChannelID == nil {
		val := random_string(nil)
		m.SlackChannelID = &val
	}
	if m.Status == nil {
		val := random_string(nil, "20")
		m.Status = &val
	}
	if m.Severity == nil {
		val := random_string(nil, "10")
		m.Severity = &val
	}
	if m.Title == nil {
		val := random_string(nil)
		m.Title = &val
	}
	if m.StartedBy == nil {
		val := random_string(nil)
		m.StartedBy = &val
	}
}

// insertOptRels creates and inserts any optional the relationships on *models.Incident
// according to the relationships in the template.
// any required relationship should have already exist on the model
func (o *IncidentTemplate) insertOptRels(ctx context.Context, exec bob.Executor, m *models.Incident) (context.Context, error) {
	var err error

	isTimelineEventsDone, _ := incidentRelTimelineEventsCtx.Value(ctx)
	if !isTimelineEventsDone && o.r.TimelineEvents != nil {
		ctx = incidentRelTimelineEventsCtx.WithValue(ctx, true)
		for _, r := range o.r.TimelineEvents {
			var rel0 models.TimelineEventSlice
			ctx, rel0, err = r.o.createMany(ctx, exec, r.number)
			if err != nil {
				return ctx, err
			}

			err = m.AttachTimelineEvents(ctx, exec, rel0...)
			if err != nil {
				return ctx, err
			}
		}
	}

	return ctx, err
}

// Create builds a incident and inserts it into the database
// Relations objects are also inserted and placed in the .R field
func (o *IncidentTemplate) Create(ctx context.Context, exec bob.Executor) (*models.Incident, error) {
	_, m, err := o.create(ctx, exec)
	return m, err
}

// MustCreate builds a incident and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o *IncidentTemplate) MustCreate(ctx context.Context, exec bob.Executor) *models.Incident {
	_, m, err := o.create(ctx, exec)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateOrFail builds a incident and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o *IncidentTemplate) CreateOrFail(ctx context.Context, tb testing.TB, exec bob.Executor) *models.Incident {
	tb.Helper()
	_, m, err := o.create(ctx, exec)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// create builds a incident and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted model
func (o *IncidentTemplate) create(ctx context.Context, exec bob.Executor) (context.Context, *models.Incident, error) {
	var err error
	opt := o.BuildSetter()
	ensureCreatableIncident(opt)

	m, err := models.Incidents.Insert(opt).One(ctx, exec)
	if err != nil {
		return ctx, nil, err
	}
	ctx = incidentCtx.WithValue(ctx, m)

	ctx, err = o.insertOptRels(ctx, exec, m)
	return ctx, m, err
}

// CreateMany builds multiple incidents and inserts them into the database
// Relations objects are also inserted and placed in the .R field
func (o IncidentTemplate) CreateMany(ctx context.Context, exec bob.Executor, number int) (models.IncidentSlice, error) {
	_, m, err := o.createMany(ctx, exec, number)
	return m, err
}

// MustCreateMany builds multiple incidents and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o IncidentTemplate) MustCreateMany(ctx context.Context, exec bob.Executor, number int) models.IncidentSlice {
	_, m, err := o.createMany(ctx, exec, number)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateManyOrFail builds multiple incidents and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o IncidentTemplate) CreateManyOrFail(ctx context.Context, tb testing.TB, exec bob.Executor, number int) models.IncidentSlice {
	tb.Helper()
	_, m, err := o.createMany(ctx, exec, number)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// createMany builds multiple incidents and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted models
func (o IncidentTemplate) createMany(ctx context.Context, exec bob.Executor, number int) (context.Context, models.IncidentSlice, error) {
	var err error
	m := make(models.IncidentSlice, number)

	for i := range m {
		ctx, m[i], err = o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	return ctx, m, nil
}

// Incident has methods that act as mods for the IncidentTemplate
var IncidentMods incidentMods

type incidentMods struct{}

func (m incidentMods) RandomizeAllColumns(f *faker.Faker) IncidentMod {
	return IncidentModSlice{
		IncidentMods.RandomID(f),
		IncidentMods.RandomSlackChannelID(f),
		IncidentMods.RandomStatus(f),
		IncidentMods.RandomSeverity(f),
		IncidentMods.RandomTitle(f),
		IncidentMods.RandomDescription(f),
		IncidentMods.RandomStartedBy(f),
		IncidentMods.RandomStartedAt(f),
		IncidentMods.RandomResolvedBy(f),
		IncidentMods.RandomResolvedAt(f),
		IncidentMods.RandomExportURL(f),
		IncidentMods.RandomLastUpdated(f),
	}
}

// Set the model columns to this value
func (m incidentMods) ID(val uuid.UUID) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ID = func() uuid.UUID { return val }
	})
}

// Set the Column from the function
func (m incidentMods) IDFunc(f func() uuid.UUID) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ID = f
	})
}

// Clear any values for the column
func (m incidentMods) UnsetID() IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m incidentMods) RandomID(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ID = func() uuid.UUID {
			return random_uuid_UUID(f)
		}
	})
}

// Set the model columns to this value
func (m incidentMods) SlackChannelID(val string) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.SlackChannelID = func() string { return val }
	})
}

// Set the Column from the function
func (m incidentMods) SlackChannelIDFunc(f func() string) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.SlackChannelID = f
	})
}

// Clear any values for the column
func (m incidentMods) UnsetSlackChannelID() IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.SlackChannelID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m incidentMods) RandomSlackChannelID(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.SlackChannelID = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m incidentMods) Status(val string) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Status = func() string { return val }
	})
}

// Set the Column from the function
func (m incidentMods) StatusFunc(f func() string) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Status = f
	})
}

// Clear any values for the column
func (m incidentMods) UnsetStatus() IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Status = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m incidentMods) RandomStatus(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Status = func() string {
			return random_string(f, "20")
		}
	})
}

// Set the model columns to this value
func (m incidentMods) Severity(val string) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Severity = func() string { return val }
	})
}

// Set the Column from the function
func (m incidentMods) SeverityFunc(f func() string) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Severity = f
	})
}

// Clear any values for the column
func (m incidentMods) UnsetSeverity() IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Severity = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m incidentMods) RandomSeverity(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Severity = func() string {
			return random_string(f, "10")
		}
	})
}

// Set the model columns to this value
func (m incidentMods) Title(val string) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Title = func() string { return val }
	})
}

// Set the Column from the function
func (m incidentMods) TitleFunc(f func() string) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Title = f
	})
}

// Clear any values for the column
func (m incidentMods) UnsetTitle() IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Title = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m incidentMods) RandomTitle(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Title = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m incidentMods) Description(val sql.Null[string]) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Description = func() sql.Null[string] { return val }
	})
}

// Set the Column from the function
func (m incidentMods) DescriptionFunc(f func() sql.Null[string]) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Description = f
	})
}

// Clear any values for the column
func (m incidentMods) UnsetDescription() IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Description = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m incidentMods) RandomDescription(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Description = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return sql.Null[string]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m incidentMods) RandomDescriptionNotNull(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.Description = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return sql.Null[string]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m incidentMods) StartedBy(val string) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.StartedBy = func() string { return val }
	})
}

// Set the Column from the function
func (m incidentMods) StartedByFunc(f func() string) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.StartedBy = f
	})
}

// Clear any values for the column
func (m incidentMods) UnsetStartedBy() IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.StartedBy = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m incidentMods) RandomStartedBy(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.StartedBy = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m incidentMods) StartedAt(val sql.Null[time.Time]) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.StartedAt = func() sql.Null[time.Time] { return val }
	})
}

// Set the Column from the function
func (m incidentMods) StartedAtFunc(f func() sql.Null[time.Time]) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.StartedAt = f
	})
}

// Clear any values for the column
func (m incidentMods) UnsetStartedAt() IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.StartedAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m incidentMods) RandomStartedAt(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.StartedAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m incidentMods) RandomStartedAtNotNull(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.StartedAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m incidentMods) ResolvedBy(val sql.Null[string]) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ResolvedBy = func() sql.Null[string] { return val }
	})
}

// Set the Column from the function
func (m incidentMods) ResolvedByFunc(f func() sql.Null[string]) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ResolvedBy = f
	})
}

// Clear any values for the column
func (m incidentMods) UnsetResolvedBy() IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ResolvedBy = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m incidentMods) RandomResolvedBy(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ResolvedBy = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return sql.Null[string]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m incidentMods) RandomResolvedByNotNull(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ResolvedBy = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return sql.Null[string]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m incidentMods) ResolvedAt(val sql.Null[time.Time]) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ResolvedAt = func() sql.Null[time.Time] { return val }
	})
}

// Set the Column from the function
func (m incidentMods) ResolvedAtFunc(f func() sql.Null[time.Time]) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ResolvedAt = f
	})
}

// Clear any values for the column
func (m incidentMods) UnsetResolvedAt() IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ResolvedAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m incidentMods) RandomResolvedAt(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ResolvedAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m incidentMods) RandomResolvedAtNotNull(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ResolvedAt = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m incidentMods) ExportURL(val sql.Null[string]) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ExportURL = func() sql.Null[string] { return val }
	})
}

// Set the Column from the function
func (m incidentMods) ExportURLFunc(f func() sql.Null[string]) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ExportURL = f
	})
}

// Clear any values for the column
func (m incidentMods) UnsetExportURL() IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ExportURL = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m incidentMods) RandomExportURL(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ExportURL = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return sql.Null[string]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m incidentMods) RandomExportURLNotNull(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.ExportURL = func() sql.Null[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return sql.Null[string]{V: val, Valid: true}
		}
	})
}

// Set the model columns to this value
func (m incidentMods) LastUpdated(val sql.Null[time.Time]) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.LastUpdated = func() sql.Null[time.Time] { return val }
	})
}

// Set the Column from the function
func (m incidentMods) LastUpdatedFunc(f func() sql.Null[time.Time]) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.LastUpdated = f
	})
}

// Clear any values for the column
func (m incidentMods) UnsetLastUpdated() IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.LastUpdated = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m incidentMods) RandomLastUpdated(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.LastUpdated = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: f.Bool()}
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m incidentMods) RandomLastUpdatedNotNull(f *faker.Faker) IncidentMod {
	return IncidentModFunc(func(_ context.Context, o *IncidentTemplate) {
		o.LastUpdated = func() sql.Null[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return sql.Null[time.Time]{V: val, Valid: true}
		}
	})
}

func (m incidentMods) WithParentsCascading() IncidentMod {
	return IncidentModFunc(func(ctx context.Context, o *IncidentTemplate) {
		if isDone, _ := incidentWithParentsCascadingCtx.Value(ctx); isDone {
			return
		}
		ctx = incidentWithParentsCascadingCtx.WithValue(ctx, true)
	})
}

func (m incidentMods) WithTimelineEvents(number int, related *TimelineEventTemplate) IncidentMod {
	return IncidentModFunc(func(ctx context.Context, o *IncidentTemplate) {
		o.r.TimelineEvents = []*incidentRTimelineEventsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m incidentMods) WithNewTimelineEvents(number int, mods ...TimelineEventMod) IncidentMod {
	return IncidentModFunc(func(ctx context.Context, o *IncidentTemplate) {
		related := o.f.NewTimelineEvent(ctx, mods...)
		m.WithTimelineEvents(number, related).Apply(ctx, o)
	})
}

func (m incidentMods) AddTimelineEvents(number int, related *TimelineEventTemplate) IncidentMod {
	return IncidentModFunc(func(ctx context.Context, o *IncidentTemplate) {
		o.r.TimelineEvents = append(o.r.TimelineEvents, &incidentRTimelineEventsR{
			number: number,
			o:      related,
		})
	})
}

func (m incidentMods) AddNewTimelineEvents(number int, mods ...TimelineEventMod) IncidentMod {
	return IncidentModFunc(func(ctx context.Context, o *IncidentTemplate) {
		related := o.f.NewTimelineEvent(ctx, mods...)
		m.AddTimelineEvents(number, related).Apply(ctx, o)
	})
}

func (m incidentMods) WithoutTimelineEvents() IncidentMod {
	return IncidentModFunc(func(ctx context.Context, o *IncidentTemplate) {
		o.r.TimelineEvents = nil
	})
}
